'''
Problem 12
Highly divisible triangular number

The sequence of triangle numbers is generated by adding the natural
numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred 
divisors?
'''

'''
Sketch of solution

The fundamental theorem of arithmetic, also called the unique factorization 
theorem or the unique-prime-factorization theorem, states that every integer 
greater than 1 is either is prime itself or is the product of prime numbers, 
and that, although the order of the primes in the second case is arbitrary, 
the primes themselves are not. For example:

1200 = 2^4 * 3^1 * 5^2 = 3*2*2*2*2*5*5 = 5*2*3*2*5*2*2 = etc.

The theorem is stating two things: first, that 1200 can be represented as a 
product of primes, and second, no matter how this is done, there will always 
be four 2s, one 3, two 5s, and no other primes in the product.

Once we have the unique prime factors and their multiplicity {i.e., maximum
power of prime that divides the number} we can generate all the factors of the
given number as a permutation of the primes. For example:

Consider n = 60

Prime factors for n = 2 * 2 * 3 * 5

All factors us a permutation of above numbers:

2
2 * 2
2 * 3
2 * 5
2 * 2 * 3
2 * 2 * 5
3 * 5
2 * 2 * 3 * 5
'''

import math
import sys

def genPrimes(primes, maxprime):
    primes.append(2)
    
    for i in range (3, maxprime, 2):
        for j in range (2, int(math.ceil(math.sqrt(i))) + 1):
            if i % j == 0:
                break
        else:
            primes.append(i)

    #print(primes)
def genPrimeFactors(n, primes, pfactors, multiplicity):  
    for prime in primes:
        temp_n = n
        if prime <= n and n % prime == 0:
            count = 0
            while True:
                if temp_n % prime == 0:
                    count += 1
                    temp_n /= prime
                else:
                    break
            pfactors.append(prime)
            multiplicity.append(count)
        
def genAllFactors(primes, multiplicity, index, factor, allfactors):
    if index == len(primes):
        #print factor
        allfactors.append(factor)
        return
    else:
        for i in range(multiplicity[index] + 1):
            genAllFactors(primes, multiplicity, index + 1, factor, allfactors)
            factor *= primes[index]
                
def EulerProblem0012():
    primes = []
    genPrimes(primes, 100)
    index = 1
    numfactors = 1
    while True:
        number = index * (index + 1) / 2        
        
        pfactors = []
        multiplicity = []
        genPrimeFactors(number, primes, pfactors, multiplicity)
        
        allfactors = []
        genAllFactors(pfactors, multiplicity, 0, 1, allfactors) 
         
        if len(allfactors) > numfactors:
            numfactors = len(allfactors)
            if numfactors > 500:
                print number, numfactors
                return
                
        index = index + 1
        
if __name__ == "__main__":
    EulerProblem0012()